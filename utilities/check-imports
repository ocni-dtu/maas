#!/usr/bin/env python3

import argparse
import ast
from collections.abc import Iterable
from glob import iglob
from itertools import (
    chain,
    islice,
)
import multiprocessing
from pathlib import Path
import re
import sys
import tokenize

# Get a list of all standard library modules.
sys.path.insert(0, Path(__file__).parent.absolute())
from python_standard_libs import python_standard_libs


def flatten(*things):
    """Recursively flatten iterable parts of `things`.

    For example::

      >>> sorted(flatten([1, 2, {3, 4, (5, 6)}]))
      [1, 2, 3, 4, 5, 6]

    :return: An iterator.
    """
    def _flatten(things):
        if isinstance(things, (bytes, str)):
            # String- and byte-like objects are treated as leaves; iterating
            # through either yields more of the same, each of which is also
            # iterable, and so on, until the heat-death of the universe.
            return iter((things,))
        elif isinstance(things, Iterable):
            # Recurse and merge in order to flatten nested structures.
            return chain.from_iterable(map(_flatten, things))
        else:
            # This is a leaf; return an single-item iterator so that it can be
            # chained with any others.
            return iter((things,))

    return _flatten(things)


class Pattern:

    def __init__(self, *patterns):
        super(Pattern, self).__init__()
        self.patterns = tuple(flatten(patterns))

    def _compile_pattern(self, pattern):
        for part in pattern.split("|"):
            expr = []
            for component in re.findall('([*]+|[^*]+)', part):
                if component == "*":
                    expr.append("[^.]+")
                elif component == "**":
                    expr.append(".+")
                elif component.count("*") >= 3:
                    raise ValueError(component)
                else:
                    expr.append(re.escape(component))
            yield "".join(expr)

    def compile(self):
        self._matcher = re.compile(
            r"(%s)\Z" % "|".join(chain.from_iterable(
                map(self._compile_pattern, self.patterns))),
            re.MULTILINE | re.DOTALL)

    def match(self, name):
        return self._matcher.match(name) is not None

    def __iter__(self):
        yield from self.patterns


ALLOWED, DENIED, INDIFFERENT = True, False, None


class Action:

    def __init__(self, *patterns):
        super(Action, self).__init__()
        self.pattern = Pattern(patterns)

    def compile(self):
        self.pattern.compile()

    def __iter__(self):
        yield from self.pattern.patterns


class Allow(Action):

    def check(self, name):
        if self.pattern.match(name):
            return ALLOWED
        else:
            return INDIFFERENT


class Deny(Action):

    def check(self, name):
        if self.pattern.match(name):
            return DENIED
        else:
            return INDIFFERENT


class Rule:

    def __init__(self, *actions):
        super(Rule, self).__init__()
        allows = {act for act in actions if isinstance(act, Allow)}
        denies = {act for act in actions if isinstance(act, Deny)}
        leftover = set(actions) - allows - denies
        if len(leftover) != 0:
            raise ValueError(
                "Expected Allow or Deny instance, got: %s"
                % ", ".join(map(repr, leftover)))
        self.allow = Allow(allows)
        self.deny = Deny(denies)

    def compile(self):
        self.allow.compile()
        self.deny.compile()

    def check(self, name):
        if self.deny.check(name) is DENIED:
            return DENIED
        elif self.allow.check(name) is ALLOWED:
            return ALLOWED
        else:
            return DENIED

    def __or__(self, other):
        if isinstance(other, self.__class__):
            return self.__class__(
                self.allow, self.deny, other.allow, other.deny)
        else:
            return self.__class__(
                self.allow, self.deny, other)


# Common module patterns.
StandardLibraries = Pattern(
    map("{0}|{0}.**".format, python_standard_libs),
    "pkg_resources",
)
TestingLibraries = Pattern(
    "distro_info.UbuntuDistroInfo",
    "django_nose|django_nose.**",
    "dns|dns.**",
    "fixtures|fixtures.**",
    "hypothesis|hypothesis.**",
    "junitxml|junitxml.**",
    "maastesting|maastesting.**",
    "nose|nose.**",
    "postgresfixture|postgresfixture.**",
    "selenium|selenium.**",
    "subunit|subunit.**",
    "testresources|testresources.**",
    "testscenarios|testscenarios.**",
    "testtools|testtools.**",
)


def files(*patterns):
    return frozenset(chain.from_iterable(
        iglob(pattern, recursive=True)
        for pattern in flatten(patterns)))


APIClient = files("src/apiclient/**/*.py")


RackControllerConfig = files(
    "src/provisioningserver/config.py")
RackControllerUtilsInit = files(
    "src/provisioningserver/utils/__init__.py")
RackControllerUtilsFS = files(
    "src/provisioningserver/utils/fs.py")
RackControllerLogging = files(
    "src/provisioningserver/logger/*.py")
RackController = (
    files("src/provisioningserver/**/*.py") -
    files("src/provisioningserver/twisted/**/*.py") -
    RackControllerConfig - RackControllerUtilsInit - RackControllerLogging -
    RackControllerUtilsFS)
RackControllerRule = Rule(
    Allow("apiclient.creds.*"),
    Allow("apiclient.maas_client.*"),
    Allow("apiclient.utils.*"),
    Allow("apt_pkg"),
    Allow("attr|attr.**"),
    Allow("bson|bson.**"),
    Allow("crochet|crochet.**"),
    # It's best to be selective about cryptography, so we're very specific.
    # These 'hazmat' modules are often not used directly, but in this case they
    # appear in the official examples from the documentation on how to use the
    # cipher with a password as a pre-shared key. See:
    #     https://cryptography.io/en/latest/fernet/#using-passwords-with-fernet
    Allow("cryptography.fernet.**"),
    Allow("cryptography.hazmat.backends.default_backend"),
    Allow("cryptography.hazmat.primitives.hashes"),
    Allow("cryptography.hazmat.primitives.kdf.pbkdf2.PBKDF2HMAC"),
    Allow("curtin|curtin.**"),
    Allow("distro_info|distro_info.*"),
    Allow("formencode|formencode.**"),
    Allow("jsonschema|jsonschema.**"),
    Allow("lxml|lxml.**"),
    # This is only allowed because of how `regiond` needs imports done
    # after the reactor has been installed. The code handles those imports
    # not being present when the machine is a rack controller only.
    Allow("maasserver.plugin.*"),
    Allow("netaddr|netaddr.**"),
    Allow("netifaces|netifaces.*"),
    Allow("oauthlib.oauth1"),
    Allow("paramiko.**"),
    Allow("pexpect"),
    Allow("prometheus_client|prometheus_client.multiprocess"),
    Allow("provisioningserver|provisioningserver.**"),
    Allow("seamicroclient|seamicroclient.**"),
    Allow("simplestreams.**"),
    Allow("tempita"),
    Allow("tftp|tftp.**"),
    Allow("twisted.**"),
    Allow("uvloop"),
    Allow("yaml"),
    Allow("zope.interface|zope.interface.**"),
    Allow(StandardLibraries),
)


RegionMigrations = files(
    "src/maasserver/migrations/**/*.py",
    "src/metadataserver/migrations/*.py")
RegionUserDataSnippets = files(
    "src/metadataserver/user_data/templates/"
    "snippets/**/*.py")
RegionController = (
    files("src/maasserver/**/*.py", "src/metadataserver/**/*.py") -
    RegionMigrations - RegionUserDataSnippets)
RegionControllerRule = Rule(
    Allow("apiclient.creds.*"),
    Allow("apiclient.multipart.*"),
    Allow("apiclient.utils.*"),
    Allow("attr|attr.**"),
    Allow("bson"),
    Allow("convoy|convoy.**"),
    Allow("crochet|crochet.**"),
    Allow("curtin|curtin.**"),
    Allow("distro_info|distro_info.*"),
    Allow("django|django.**"),
    Allow("docutils.core"),
    Allow("formencode|formencode.**"),
    Allow("jsonschema|jsonschema.**"),
    Allow("lxml|lxml.**"),
    Allow("maascli.init.**"),
    Allow("maascli.utils.parse_docstring"),
    Allow("maasserver|maasserver.**"),
    Allow("macaroonbakery|macaroonbakery.**"),
    Allow("markupsafe|markupsafe.**"),
    Allow("metadataserver|metadataserver.**"),
    Allow("netaddr|netaddr.**"),
    Allow("oauth|oauth.**"),
    Allow("OpenSSL|OpenSSL.**"),
    Allow("petname"),
    Allow("piston3|piston3.**"),
    Allow("prometheus_client"),
    Allow("provisioningserver|provisioningserver.**"),
    Allow("psycopg2|psycopg2.**"),
    Allow("pytz.UTC"),
    Allow("requests|requests.**"),
    Allow("simplestreams.**"),
    Allow("tempita"),
    Allow("twisted.**"),
    Allow("yaml"),
    Allow("zope.interface|zope.interface.**"),
    Allow("oauthlib.oauth1"),
    Allow(StandardLibraries),
)


Tests = files(
    "src/**/test_*.py",
    "src/**/testing/**/*.py",
    "src/**/testing.py")


TestScriptEntryPoints = files("src/maastesting/scripts.py")
TestHelpers = files("src/maastesting/**/*.py") - TestScriptEntryPoints

TestHelpersRule = Rule(
    Allow("crochet|crochet.**"),
    Allow("django|django.**"),
    Allow("netaddr|netaddr.**"),
    Allow("twisted.**"),
    Allow(StandardLibraries),
    Allow(TestingLibraries),
)


TestScriptEntryPointsRule = Rule(
    Allow("asyncio"),
    Allow("os|sys"),
    Allow("django|django.**"),
    Allow("maasserver|maasserver.**"),
    Allow("maastesting.**"),
    Allow("provisioningserver.**"),
    Allow("twisted.**"),
    Allow("uvloop"),
)


checks = [
    #
    # API CLIENT
    #
    (
        APIClient - Tests,
        Rule(
            Allow("apiclient|apiclient.**"),
            Allow("django.utils.**"),
            Allow("oauth.oauth"),
            Allow(StandardLibraries),
        ),
    ),
    (
        APIClient & Tests,
        Rule(
            Allow("apiclient|apiclient.**"),
            Allow("django.**"),
            Allow("oauth.oauth"),
            Allow("piston3|piston3.**"),
            Allow(StandardLibraries),
            Allow(TestingLibraries),
        ),
    ),
    #
    # RACK CONTROLLER
    #
    (
        RackController - Tests,
        RackControllerRule,
    ),
    (
        RackControllerConfig | RackControllerUtilsFS,
        RackControllerRule | Allow("maastesting.root"),
    ),
    (
        RackControllerUtilsInit,
        RackControllerRule | Rule(
            Allow("maastesting.typecheck.typed"),
            Allow("provisioningserver.path.get_tentative_path"),
            Allow("tempita"),
            Allow(StandardLibraries),
        ),
    ),
    (
        RackController & Tests,
        RackControllerRule | Rule(
            Allow("apiclient.testing.credentials.make_api_credentials"),
            Allow(StandardLibraries),
            Allow(TestingLibraries),
        ),
    ),
    (
        RackControllerLogging,
        RackControllerRule | Rule(
            Allow("django.utils.log"),
            Allow("django.utils.deprecation.*"),
        ),
    ),
    #
    # REGION CONTROLLER
    #
    (
        RegionController - Tests,
        RegionControllerRule,
    ),
    (
        RegionUserDataSnippets - Tests,
        RegionControllerRule | Rule(
            Allow("maas_api_helper.**"),
            Allow("snippets.**"),
        ),
    ),
    (
        RegionMigrations,
        Rule(
            Allow("django|django.**"),
            Allow("netaddr|netaddr.**"),
            Allow("petname"),
            Allow("piston3.models"),
            Allow(StandardLibraries),

            # XXX: The following three permissions are temporary;
            # they MUST be eliminated before MAAS 2.0 release.
            Allow("maasserver|maasserver.**"),
            Allow("metadataserver|metadataserver.**"),
            Allow("provisioningserver|provisioningserver.**"),
        )
    ),
    (
        RegionController & Tests,
        RegionControllerRule | Rule(
            Allow(TestingLibraries),
        ),
    ),
    (
        RegionUserDataSnippets & Tests,
        RegionControllerRule | Rule(
            Allow("snippets.**"),
            Allow(StandardLibraries),
            Allow(TestingLibraries),
        ),
    ),
    #
    # TESTING HELPERS
    #
    (
        TestHelpers,
        TestHelpersRule,
    ),
    (
        TestScriptEntryPoints,
        TestScriptEntryPointsRule,
    ),
]


def extract(node):
    """Extract all imports from the given AST node."""
    for node in ast.walk(node):
        if isinstance(node, ast.Import):
            for alias in node.names:
                yield alias.name
        elif isinstance(node, ast.ImportFrom):
            for alias in node.names:
                # Note that `node.module is None` if the import in the format:
                #     from . import <thing>
                module = '.' if node.module is None else node.module
                yield "%s.%s" % (module, alias.name)
        else:
            pass  # Not an import.


def _batch(objects, size):
    """Generate batches of `size` elements from `objects`.

    Each batch is a list of `size` elements exactly, except for the last which
    may contain fewer than `size` elements.
    """
    objects = iter(objects)
    batch = lambda: list(islice(objects, size))
    return iter(batch, [])


def _expand(checks):
    """Generate `(rule, batch-of-filenames)` for the given checks.

    It batches filenames to reduce the serialise/unserialise overhead when
    calling out to a pooled process.
    """
    for filenames, rule in checks:
        rule.compile()  # Compile or it's slow.
        for filenames in _batch(filenames, 100):
            yield rule, filenames


def _scan1(rule, filename):
    """Scan one file and check against the given rule."""
    with tokenize.open(filename) as fd:
        module = ast.parse(fd.read())
    imports = set(extract(module))
    allowed = set(filter(rule.check, imports))
    denied = imports.difference(allowed)
    return filename, allowed, denied


def _scan(rule, filenames):
    """Scan the files and check against the given rule."""
    return [_scan1(rule, filename) for filename in filenames]


def scan(checks):
    """Scan many files and check against the given rules."""
    with multiprocessing.Pool() as pool:
        for results in pool.starmap(_scan, _expand(checks)):
            yield from results


if sys.stdout.isatty():

    def print_filename(filename):
        print('\x1b[36m' + filename + '\x1b[39m')

    def print_allowed(name):
        print(" \x1b[32mallowed:\x1b[39m", name)

    def print_denied(name):
        print("  \x1b[31mdenied:\x1b[39m", name)

else:

    def print_filename(filename):
        print(filename)

    def print_allowed(name):
        print(" allowed:", name)

    def print_denied(name):
        print("  denied:", name)


def main(args):
    parser = argparse.ArgumentParser(
        description="Statically check imports against policy.",
        add_help=False)
    parser.add_argument(
        "--show-allowed", action="store_true", dest="show_allowed",
        help="Log allowed imports.")
    parser.add_argument(
        "--hide-denied", action="store_false", dest="show_denied",
        help="Log denied imports.")
    parser.add_argument(
        "--hide-summary", action="store_false", dest="show_summary",
        help="Show summary of allowed and denied imports.")
    parser.add_argument(
        "-h", "--help", action="help", help=argparse.SUPPRESS)
    options = parser.parse_args(args)

    allowedcount, deniedcount = 0, 0
    for filename, allowed, denied in scan(checks):
        allowedcount += len(allowed)
        deniedcount += len(denied)
        show_filename = (
            (options.show_allowed and len(allowed) != 0) or
            (options.show_denied and len(denied) != 0))
        if show_filename:
            print_filename(filename)
        if options.show_allowed and len(allowed) != 0:
            for imported_name in sorted(allowed):
                print_allowed(imported_name)
        if options.show_denied and len(denied) != 0:
            for imported_name in sorted(denied):
                print_denied(imported_name)

    if options.show_summary:
        if (options.show_allowed and allowedcount != 0):
            print()
        elif (options.show_denied and deniedcount != 0):
            print()

        print(allowedcount, "imported names were ALLOWED.")
        print(deniedcount, "imported names were DENIED.")

    return deniedcount == 0


if __name__ == '__main__':
    raise SystemExit(0 if main(sys.argv[1:]) else 1)
